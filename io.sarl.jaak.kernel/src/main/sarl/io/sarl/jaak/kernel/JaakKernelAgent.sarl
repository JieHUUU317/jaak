/*
 * $Id$
 *
 * Jaak environment model is an open-source multiagent library.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014 St√©phane GALLAND.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.jaak.kernel

import io.sarl.core.AgentTask
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Schedules
import io.sarl.jaak.envinterface.time.TimeManager
import io.sarl.jaak.environment.model.JaakEnvironment
import io.sarl.jaak.spawner.JaakSpawner
import io.sarl.jaak.spawner.JaakWorldSpawner
import io.sarl.jaak.util.RandomNumber
import io.sarl.lang.core.Agent
import java.util.Collections
import java.util.List
import java.util.Map
import java.util.UUID
import java.util.concurrent.atomic.AtomicBoolean
import org.arakhne.afc.math.continous.object2d.Vector2f
import io.sarl.lang.core.Address

/** Provide the core agent which is responsible of the Jaak environment.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
agent JaakKernelAgent {

	uses DefaultContextInteractions, Lifecycle, Schedules
	
	val waitingDuration = 5000

	val listeners : List<JaakListener> = newArrayList
	val removedAgents : List<UUID> = newLinkedList
	val addedAgents : Map<UUID, TurtleCreated> = newTreeMap(null)
	val isWaitingInfluences = new AtomicBoolean(false)
	val controller : JaakController = new JaakKernelController
	var physicSpace : JaakPhysicSpace
	var defaultAddressInPhysicSpace : Address
	var physicEnvironment : JaakEnvironment
	var timeManager : TimeManager
	var spawners : JaakSpawner[]
	var defaultSpawner : JaakWorldSpawner 
	var waitingTask : AgentTask
	
	def addJaakListener(listener : JaakListener) {
		synchronized(listeners) {
			listeners += listener
		}
	}
	
	def removeJaakListener(listener : JaakListener) {
		synchronized(listeners) {
			listeners += listener
		}
	}
	
	def fireSimulationStarted() {
		var list : JaakListener[]
		synchronized(listeners) {
			list = newArrayOfSize(listeners.size)
			listeners.toArray(list)
		}
		var evt = new JaakEvent(this,
			physicEnvironment,
			Collections.unmodifiableCollection(spawners),
			timeManager.currentTime,
			timeManager.lastStepDuration
		)
		for(listener : list) {
			listener.simulationStarted(evt)
		}
	}

	def fireSimulationStopped() {
		var list : JaakListener[]
		synchronized(listeners) {
			list = newArrayOfSize(listeners.size)
			listeners.toArray(list)
		}
		var evt = new JaakEvent(this,
			physicEnvironment,
			Collections.unmodifiableCollection(spawners),
			timeManager.currentTime,
			timeManager.lastStepDuration
		)
		for(listener : list) {
			listener.simulationStopped(evt)
		}
	}

	def fireEnvironmentChange() {
		var list : JaakListener[]
		synchronized(listeners) {
			list = newArrayOfSize(listeners.size)
			listeners.toArray(list)
		}
		var evt = new JaakEvent(this,
			physicEnvironment,
			Collections.unmodifiableCollection(spawners),
			timeManager.currentTime,
			timeManager.lastStepDuration
		)
		for(listener : list) {
			listener.environmentStateChanged(evt)
		}
	}

	on Initialize {
		var spaceId = UUID::fromString(defaultContext.ID.toString + "!!!JaakPhysicSpace")
		physicSpace = defaultContext.getOrCreateSpace(
			typeof(JaakPhysicSpaceSpecification),
			spaceId, ID)
		// Ensure that the agent is the creator of the space.
		if (physicSpace.creatorID != ID) {
			killMe
		} else {
			// Create the physic environment
			defaultAddressInPhysicSpace = new Address(physicSpace.ID, ID)
			timeManager = createTimeManager
			physicEnvironment = createEnvironment
			physicEnvironment.setTimeManager(timeManager)
			defaultSpawner = new JaakWorldSpawner(physicEnvironment)
			var p = createSpawners
			if (p === null || p.empty) {
				spawners = Collections.singletonList(defaultSpawner)
			} else {
				spawners = p
			}
			(controller as JaakKernelController).initialize(
				defaultSpace,
				defaultAddress,
				timeManager
			)
		}
	}
	
	on Destroy [physicEnvironment !== null] {
		isWaitingInfluences.set(false)
		if (waitingTask !== null) {
			waitingTask.cancel
			waitingTask = null
		}
		physicEnvironment = null
	}
	
	on TurtleCreated [occurrence.isValid] {
		synchronized(addedAgents) {
			addedAgents.put(
				occurrence.source.UUID,
				occurrence
			)
		}
	}
	
	on TurtleDestroyed [occurrence.isValid] {
		synchronized(removedAgents) {
			removedAgents.add(occurrence.source.UUID)
		}
	}

	on Move [occurrence.isValid] {
		var body = physicEnvironment.getBodyFor(occurrence.movedObject)
		if (body !== null) {
			body.move(new Vector2f(occurrence.linearMotionX, occurrence.linearMotionY), false)
			if (occurrence.angularMotion >= 0) {
				body.turnRight(occurrence.angularMotion)
			} else {
				body.turnLeft(-occurrence.angularMotion)
			}
		}
	}
	
	on DropDown [occurrence.isValid] {
		synchronized(this) {
			var body = physicEnvironment.getBodyFor(occurrence.source.UUID)
			if (body !== null) {
				body.dropOff(occurrence.object)
			}
		}
	}

	on PickUp [occurrence.isValid] {
		synchronized(this) {
			var body = physicEnvironment.getBodyFor(occurrence.source.UUID)
			if (body !== null) {
				if (occurrence.type !== null) {
					body.pickUp(occurrence.type)
				} else if (occurrence.object !== null) {
					body.pickUp(occurrence.object)
				}
			}
		}
	}
	
	on SimulationStarted [occurrence.fromMe] {
		runPreAgentExecution
	}

	on ExecuteSimulationStep [occurrence.fromMe] {
		runPostAgentExecution
		runPreAgentExecution
	}

	on SimulationStopped [occurrence.fromMe] {
		killMe
	}

	def isValid(evt : StampedEvent) : boolean {
		physicEnvironment !== null
		&& evt.source.spaceId == physicSpace.ID
		&& isWaitingInfluences.get
		&& timeManager.currentTime <= evt.currentTime
	}

	/* Run the tasks before the agent executions.
	 */
	def runPreAgentExecution {
		if (spawners !== null) {
			var factory = physicEnvironment.turtleBodyFactory
			
			for(spawner : spawners) {
				var id = UUID::randomUUID
				if (spawner.spawnBodyFor(
	            		  id,
	            		  ID,
	            		  factory,
	            		  this.timeManager,
	            		  null)) {
	            	spawnInContextWithID(
	            		getSpawnableAgentType(spawner),
	            		id, 
	            		defaultContext)
	            }
			}

			synchronized(removedAgents) {
				var iterator = this.removedAgents.iterator
				while (iterator.hasNext) {
					var adr = iterator.next
					iterator.remove
					physicEnvironment.removeBodyFor(adr)
				}
			}

			synchronized(addedAgents) {
				var iterator = this.addedAgents.entrySet.iterator
				var creator : AgentBodyCreator = new AgentBodyCreator
				while (iterator.hasNext) {
					var p = iterator.next
					creator.set(p.value) 
					iterator.remove
					if (creator.isPositionForced(physicEnvironment)) {
						defaultSpawner.spawnBodyFor(
			            		  p.key,
			            		  ID,
			            		  factory,
			            		  this.timeManager,
			            		  creator)
					} else {
						var spawner = this.spawners.get(
							RandomNumber.nextInt(this.spawners.length)
						)
						spawner.spawnBodyFor(
			            		  p.key,
			            		  ID,
			            		  factory,
			            		  this.timeManager,
			            		  creator)
					}
				}
			}
		}
		physicEnvironment.runPreTurtles
		//		
		if (waitingTask !== null) {
			waitingTask.cancel
			waitingTask = null
		}
		waitingTask = in(waitingDuration) [
			(controller as JaakKernelController).wakeSimulator
		]
		isWaitingInfluences.set(true)
		//
		physicEnvironment.apply [
			var evt = new Perception(
				timeManager.currentTime,
				timeManager.lastStepDuration, 
				it.lastMotionInfluenceStatus,
				it.perception)
			evt.source = defaultAddressInPhysicSpace
			physicSpace.emit(evt, it.turtleId)
		]
	}

	/* Run the tasks after the agent executions.
	 */
	def runPostAgentExecution {
		isWaitingInfluences.set(false)
		physicEnvironment.runPostTurtles
		timeManager.increment
	}
	
	/* Create an instance of the time manager that must be used by
	 * the Jaak kernel.
	 * 
	 * @return the instance of time manager.
	 */
	def createTimeManager : TimeManager {
		new DefaultJaakTimeManager()
	}
	
	/* Create the spawners to put on the environment
	 * at the start up of the simulation.
	 * 
	 * @return the start-up spawners.
	 */
	def createSpawners() : JaakSpawner[] {
		#[] 
	}
	
	/* Create an instance of the environment that must
	 * be used by the Jaak kernel.
	 * 
	 * @return the instance of time manager.
	 */
	def createEnvironment : JaakEnvironment {
		throw new UnsupportedOperationException("must be overridden")
	}

	/* Replies the type of the agents to spawn.
	 *
	 * @param spawner - the spawner that will create the agent.
	 */
	def getSpawnableAgentType(spawner : JaakSpawner) : Class<? extends Agent> {
		throw new UnsupportedOperationException("must be overridden")
	}

}